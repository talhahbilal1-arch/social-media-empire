name: System Health

on:
  schedule:
    # Every 6 hours
    - cron: '0 */6 * * *'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        type: choice
        options:
          - full_check
          - health_only
          - self_heal
          - cleanup

env:
  PYTHON_VERSION: '3.11'

jobs:
  health-check:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      status: ${{ steps.check.outputs.status }}
      issues: ${{ steps.check.outputs.issues }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run health check
        id: check
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          PEXELS_API_KEY: ${{ secrets.PEXELS_API_KEY }}
          CREATOMATE_API_KEY: ${{ secrets.CREATOMATE_API_KEY }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
          LATE_API_KEY: ${{ secrets.LATE_API_KEY }}
          LATE_API_KEY_3: ${{ secrets.LATE_API_KEY_3 }}
          CONVERTKIT_API_KEY: ${{ secrets.CONVERTKIT_API_KEY }}
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          ELEVENLABS_API_KEY: ${{ secrets.ELEVENLABS_API_KEY }}
          NETLIFY_API_TOKEN: ${{ secrets.NETLIFY_API_TOKEN }}
          YOUTUBE_CLIENT_ID: ${{ secrets.YOUTUBE_CLIENT_ID }}
          YOUTUBE_CLIENT_SECRET: ${{ secrets.YOUTUBE_CLIENT_SECRET }}
          YOUTUBE_REFRESH_TOKEN: ${{ secrets.YOUTUBE_REFRESH_TOKEN }}
          MAKE_COM_PINTEREST_WEBHOOK: ${{ secrets.MAKE_COM_PINTEREST_WEBHOOK }}
        run: |
          python -c "
          import os
          import sys
          import json

          sys.path.insert(0, '.')
          from monitoring.health_checker import run_health_check

          result = run_health_check(full=True)

          status = result['overall_status']
          issues = []

          for check in result.get('checks', []):
              svc = check['service']
              svc_status = check['status']
              if svc_status == 'healthy':
                  rt = check.get('response_time_ms')
                  rt_str = f' ({rt:.0f}ms)' if rt else ''
                  print(f'{svc}: OK{rt_str}')
              else:
                  err = check.get('error', 'unknown')
                  issues.append(f'{svc}: {err}')
                  print(f'{svc}: {svc_status.upper()} - {err}')

          summary = result.get('summary', {})
          print(f'\nSummary: {summary.get(\"healthy\", 0)} healthy, {summary.get(\"degraded\", 0)} degraded, {summary.get(\"unhealthy\", 0)} unhealthy out of {summary.get(\"total\", 0)} services')

          if issues:
              print(f'\nIssues found ({len(issues)}):')
              for i in issues:
                  print(f'  - {i}')

          # Write outputs
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f'status={status}\n')
              f.write(f'issues={json.dumps(issues)}\n')

          print(f'\nOverall status: {status}')
          "

  self-heal:
    runs-on: ubuntu-latest
    needs: health-check
    if: >
      needs.health-check.outputs.status != 'healthy' ||
      github.event.inputs.action == 'self_heal' ||
      github.event.inputs.action == 'full_check'
    timeout-minutes: 15

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Attempt self-healing
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          ALERT_EMAIL: ${{ secrets.ALERT_EMAIL }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python -c "
          import sys
          import json
          sys.path.insert(0, '.')
          from database.supabase_client import get_supabase_client
          from datetime import datetime, timedelta

          db = get_supabase_client()

          # --- Phase 1: Workflow Guardian analysis ---
          print('=== Workflow Guardian: Analyzing recent failures ===')
          try:
              from monitoring.workflow_guardian import WorkflowGuardian
              guardian = WorkflowGuardian()
              result = guardian.analyze_and_heal(hours=6)
              print(f'Analyzed: {result[\"analyzed\"]} failed runs')
              print(f'Retried: {result[\"retried\"]}')
              print(f'Alerted: {result[\"alerted\"]}')
              print(f'Issues created: {result[\"issues_created\"]}')
              if result['failures_by_category']:
                  print(f'Failure categories: {json.dumps(result[\"failures_by_category\"])}')
          except Exception as e:
              print(f'Workflow Guardian analysis failed (non-fatal): {e}')

          # --- Phase 2: Review content engine errors ---
          print('\n=== Content Engine: Reviewing errors ===')
          try:
              yesterday = (datetime.utcnow() - timedelta(hours=24)).isoformat()
              errors = db.client.table('errors').select('*') \
                  .eq('error_type', 'content_engine') \
                  .gte('created_at', yesterday) \
                  .execute()
              if errors.data:
                  print(f'Found {len(errors.data)} content engine errors in last 24h')
                  for err in errors.data:
                      db.client.table('errors').update({'resolved': True}) \
                          .eq('id', err['id']).execute()
              else:
                  print('No recent content engine errors')
          except Exception as e:
              print(f'Self-healing error check failed: {e}')

          # --- Phase 3: Review workflow failure errors ---
          print('\n=== Workflow Failures: Reviewing errors ===')
          try:
              yesterday = (datetime.utcnow() - timedelta(hours=24)).isoformat()
              wf_errors = db.client.table('errors').select('*') \
                  .eq('error_type', 'workflow_failure') \
                  .gte('created_at', yesterday) \
                  .execute()
              if wf_errors.data:
                  print(f'Found {len(wf_errors.data)} workflow failure errors in last 24h')
                  for err in wf_errors.data:
                      print(f'  - {err.get(\"message\", err.get(\"error_message\", \"unknown\"))}')
              else:
                  print('No recent workflow failure errors')
          except Exception as e:
              print(f'Workflow error review failed: {e}')

          # --- Phase 4: Clean old data ---
          print('\n=== Cleanup: Removing old resolved errors ===')
          try:
              cutoff_30d = (datetime.utcnow() - timedelta(days=30)).isoformat()
              db.client.table('errors').delete() \
                  .eq('resolved', True) \
                  .lt('created_at', cutoff_30d).execute()
              print('Cleaned resolved errors older than 30 days')
          except Exception as e:
              print(f'Cleanup failed: {e}')
          "

  alert:
    runs-on: ubuntu-latest
    needs: health-check
    if: needs.health-check.outputs.status == 'unhealthy'
    timeout-minutes: 5

    steps:
      - name: Send alert
        env:
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          ALERT_EMAIL: ${{ secrets.ALERT_EMAIL }}
        run: |
          python -c "
          import os
          import resend

          resend_key = os.environ.get('RESEND_API_KEY', '')
          alert_email = os.environ.get('ALERT_EMAIL', '')

          if not resend_key or not alert_email:
              print('Alert email not configured')
              exit(0)

          resend.api_key = resend_key
          resend.Emails.send({
              'from': 'alerts@socialmediaempire.com',
              'to': [alert_email],
              'subject': 'UNHEALTHY: Social Media Empire System Alert',
              'html': '<h1>System Health Alert</h1><p>Status: UNHEALTHY</p><p>Issues: ${{ needs.health-check.outputs.issues }}</p><p>Check GitHub Actions for details.</p>'
          })
          print('Alert sent')
          "
