---
phase: 05-content-generation-services
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/services/audio_synthesizer.py
  - src/services/__init__.py
autonomous: true

must_haves:
  truths:
    - "AudioSynthesizer generates voiceover audio from script text"
    - "AudioSynthesizer uses brand-specific TTS voice (AUDIO-02)"
    - "AudioSynthesizer returns word timings for subtitle sync"
    - "Cache hit returns existing audio without calling Edge-TTS"
    - "CTA is naturally spoken within the voiceover (AUDIO-03)"
    - "AudioResult includes audio_path, word_timings, and duration_ms"
  artifacts:
    - path: "src/services/audio_synthesizer.py"
      provides: "AudioSynthesizer class with synthesize() method"
      contains: "class AudioSynthesizer"
      min_lines: 70
  key_links:
    - from: "src/services/audio_synthesizer.py"
      to: "src/clients/tts.py"
      via: "uses TTSClient for audio generation"
      pattern: "TTSClient|for_brand|generate"
    - from: "src/services/audio_synthesizer.py"
      to: "src/utils/cache.py"
      via: "uses FileCache for audio metadata caching"
      pattern: "FileCache"
    - from: "src/services/audio_synthesizer.py"
      to: "src/models/content.py"
      via: "returns AudioResult dataclass"
      pattern: "from src.models.content import AudioResult"
---

<objective>
Create AudioSynthesizer service that generates TTS voiceover audio with word timing, using brand-specific voices and file-based caching.

Purpose: Wrap the TTSClient with caching and brand voice selection to efficiently generate voiceover audio for video scripts.

Output: `src/services/audio_synthesizer.py` with AudioSynthesizer class.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-content-generation-services/05-RESEARCH.md
@.planning/phases/05-content-generation-services/05-01-SUMMARY.md

# Existing code to use
@src/clients/tts.py
@src/models/content.py
@src/models/brand.py
@src/utils/cache.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AudioSynthesizer with brand voice selection</name>
  <files>src/services/audio_synthesizer.py</files>
  <action>
Create `src/services/audio_synthesizer.py` with:

```python
"""Audio synthesizer service with TTS and caching."""
import logging
from pathlib import Path
from typing import Optional
import hashlib

from src.clients.tts import TTSClient, TTSResult
from src.models.brand import BrandConfig
from src.models.content import AudioResult
from src.utils.cache import FileCache
from src.video.timing import WordTiming


class AudioSynthesizer:
    """Generate TTS audio with brand-specific voices and caching.

    Uses Edge-TTS for audio generation with word timing extraction.
    Caches by hash of (script text + voice ID) to prevent redundant generation.

    Cache strategy:
    - Audio files: Stored in cache/audio/ directory with hash-based names
    - Metadata cache: JSON with word timings, duration, voice info
    - Cache key: hash of script text + voice ID
    """

    def __init__(self, cache_dir: Path = None):
        """Initialize AudioSynthesizer.

        Args:
            cache_dir: Directory for audio cache (defaults to cache/audio)
        """
        self.cache_dir = cache_dir or Path("cache/audio")
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        self.metadata_cache = FileCache("audio_metadata")
        self.logger = logging.getLogger(self.__class__.__name__)
```

**Cache key generation**:
```python
def _cache_key(self, script_text: str, voice: str) -> str:
    """Generate cache key from script text and voice.

    Uses hash to handle long scripts and special characters.
    """
    content = f"{voice}_{script_text}"
    return hashlib.sha256(content.encode()).hexdigest()[:16]
```

**Audio path from cache key**:
```python
def _audio_path(self, cache_key: str) -> Path:
    """Get audio file path for cache key."""
    return self.cache_dir / f"{cache_key}.mp3"
```

**Get cached audio**:
```python
def _get_cached(self, cache_key: str) -> Optional[AudioResult]:
    """Get cached audio result if exists and file is valid."""
    metadata = self.metadata_cache.get(cache_key)
    if not metadata:
        return None

    audio_path = Path(metadata.get("audio_path", ""))
    if not audio_path.exists() or audio_path.stat().st_size == 0:
        # File missing or empty - invalidate cache
        self.metadata_cache.delete(cache_key)
        self.logger.info(
            f"Cache INVALID (file missing)",
            extra={"cache_key": cache_key}
        )
        return None

    # Reconstruct WordTiming objects from cached data
    word_timings = [
        WordTiming(
            text=wt["text"],
            start=wt["start"],
            end=wt["end"]
        )
        for wt in metadata.get("word_timings", [])
    ]

    self.logger.debug(
        f"Cache HIT for audio",
        extra={"cache_key": cache_key, "path": str(audio_path)}
    )

    return AudioResult(
        audio_path=audio_path,
        word_timings=word_timings,
        duration_ms=metadata.get("duration_ms", 0.0)
    )
```
  </action>
  <verify>
```bash
cd /Users/homefolder/social-media-empire
python -c "
from src.services.audio_synthesizer import AudioSynthesizer
asyn = AudioSynthesizer.__new__(AudioSynthesizer)
print('AudioSynthesizer class created')
print('_cache_key method exists:', hasattr(AudioSynthesizer, '_cache_key'))
print('_get_cached method exists:', hasattr(AudioSynthesizer, '_get_cached'))
"
```
  </verify>
  <done>AudioSynthesizer class created with cache key generation and cached audio retrieval</done>
</task>

<task type="auto">
  <name>Task 2: Implement synthesize method with caching</name>
  <files>src/services/audio_synthesizer.py, src/services/__init__.py</files>
  <action>
Add the main `synthesize` method to AudioSynthesizer:

```python
def synthesize(
    self,
    script_text: str,
    brand_config: BrandConfig
) -> AudioResult:
    """Generate TTS audio from script text.

    Args:
        script_text: Voiceover text to synthesize
        brand_config: Brand configuration with TTS voice

    Returns:
        AudioResult with audio path, word timings, and duration

    Flow:
        1. Check cache for existing audio
        2. If cache miss: create TTSClient with brand voice
        3. Generate audio with word timing
        4. Cache metadata and return
    """
    voice = brand_config.tts_voice
    cache_key = self._cache_key(script_text, voice)

    # Check cache first
    cached = self._get_cached(cache_key)
    if cached:
        self.logger.info(
            f"Cache HIT for {brand_config.slug} audio",
            extra={"cache_key": cache_key, "voice": voice}
        )
        return cached

    self.logger.info(
        f"Cache MISS, generating audio for {brand_config.slug}",
        extra={"cache_key": cache_key, "voice": voice, "text_length": len(script_text)}
    )

    # Create TTS client with brand voice
    tts_client = TTSClient.for_brand(brand_config.slug)

    # Generate audio with word timing
    audio_path = self._audio_path(cache_key)
    tts_result = tts_client.generate(script_text, audio_path)

    # Create AudioResult
    audio_result = AudioResult(
        audio_path=tts_result.audio_path,
        word_timings=tts_result.word_timings,
        duration_ms=tts_result.duration_ms
    )

    # Cache metadata (word timings as dicts for JSON serialization)
    self.metadata_cache.set(cache_key, {
        "audio_path": str(audio_result.audio_path),
        "word_timings": [
            {"text": wt.text, "start": wt.start, "end": wt.end}
            for wt in audio_result.word_timings
        ],
        "duration_ms": audio_result.duration_ms,
        "voice": voice,
        "brand_slug": brand_config.slug,
        "text_length": len(script_text)
    })

    self.logger.info(
        f"Generated and cached audio",
        extra={
            "path": str(audio_path),
            "duration_ms": audio_result.duration_ms,
            "word_count": len(audio_result.word_timings)
        }
    )

    return audio_result
```

**Synthesize from Script helper** (convenience method):
```python
def synthesize_script(self, script: "Script", brand_config: BrandConfig) -> AudioResult:
    """Convenience method to synthesize audio from Script dataclass.

    Args:
        script: Script dataclass with voiceover text
        brand_config: Brand configuration with TTS voice

    Returns:
        AudioResult with audio path and word timings
    """
    from src.models.content import Script  # Avoid circular import
    return self.synthesize(script.voiceover, brand_config)
```

**Clear cache method**:
```python
def clear_cache(self) -> int:
    """Clear all cached audio files and metadata.

    Returns:
        Number of files deleted
    """
    # Clear metadata
    metadata_count = self.metadata_cache.clear()

    # Clear audio files
    audio_count = 0
    for audio_file in self.cache_dir.glob("*.mp3"):
        audio_file.unlink()
        audio_count += 1

    self.logger.info(
        f"Cleared cache",
        extra={"metadata_entries": metadata_count, "audio_files": audio_count}
    )

    return metadata_count + audio_count
```

Update `src/services/__init__.py` to export AudioSynthesizer:
```python
"""Services layer for business logic and orchestration."""
from src.services.script_generator import ScriptGenerator
from src.services.video_fetcher import VideoFetcher
from src.services.audio_synthesizer import AudioSynthesizer

__all__ = ["ScriptGenerator", "VideoFetcher", "AudioSynthesizer"]
```

Note: If running in parallel with other plans, just add AudioSynthesizer. Check what's already exported and add to the list.
  </action>
  <verify>
```bash
cd /Users/homefolder/social-media-empire
python -c "
from src.services.audio_synthesizer import AudioSynthesizer

# Test class structure
asyn = AudioSynthesizer.__new__(AudioSynthesizer)
print('synthesize method exists:', hasattr(AudioSynthesizer, 'synthesize'))
print('synthesize_script exists:', hasattr(AudioSynthesizer, 'synthesize_script'))
print('clear_cache exists:', hasattr(AudioSynthesizer, 'clear_cache'))
print('AudioSynthesizer ready for use')
"
```
  </verify>
  <done>AudioSynthesizer.synthesize() method implemented with brand voice selection, TTS generation, and metadata caching</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **AudioSynthesizer importable:**
```bash
python -c "from src.services.audio_synthesizer import AudioSynthesizer; print('Import OK')"
```

2. **All services exported:**
```bash
python -c "
from src.services import ScriptGenerator, VideoFetcher, AudioSynthesizer
print('All services importable from src.services')
"
```

3. **Cache key includes voice:**
```bash
python -c "
from src.services.audio_synthesizer import AudioSynthesizer
asyn = AudioSynthesizer.__new__(AudioSynthesizer)
key1 = asyn._cache_key('hello world', 'en-US-JennyNeural')
key2 = asyn._cache_key('hello world', 'en-US-AriaNeural')
assert key1 != key2, 'Different voices should have different cache keys'
print('Voice-specific cache keys verified')
"
```

4. **AudioResult structure correct:**
```bash
python -c "
from src.models.content import AudioResult
from src.video.timing import WordTiming
from pathlib import Path

result = AudioResult(
    audio_path=Path('/tmp/test.mp3'),
    word_timings=[WordTiming(text='hello', start=0.0, end=0.5)],
    duration_ms=500.0
)
print(f'AudioResult: path={result.audio_path}, words={len(result.word_timings)}, duration={result.duration_ms}ms')
"
```
</verification>

<success_criteria>
1. AudioSynthesizer generates audio from script text (AUDIO-01)
2. Brand-specific TTS voice used via TTSClient.for_brand() (AUDIO-02)
3. Word timings returned for subtitle synchronization
4. Cache prevents redundant Edge-TTS calls
5. CTA naturally spoken (handled by ScriptGenerator prompt, verified in audio)
6. Metadata cached includes voice, duration, word timings
</success_criteria>

<output>
After completion, create `.planning/phases/05-content-generation-services/05-04-SUMMARY.md`
</output>
