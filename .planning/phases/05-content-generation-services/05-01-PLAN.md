---
phase: 05-content-generation-services
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/models/content.py
  - src/models/__init__.py
  - src/utils/cache.py
  - src/utils/__init__.py
autonomous: true

must_haves:
  truths:
    - "Script dataclass holds topic, voiceover, search_terms, brand_slug, cta_text, estimated_duration"
    - "AudioResult dataclass holds audio_path, word_timings, duration_ms"
    - "GeneratedContent dataclass holds script, video_path, audio_result, metadata"
    - "Cache utility generates deterministic hash keys from input strings"
    - "Cache get/set operations work with JSON-serializable data"
    - "Cache hit returns cached data without file I/O errors"
  artifacts:
    - path: "src/models/content.py"
      provides: "Script, AudioResult, GeneratedContent dataclasses"
      contains: "@dataclass"
      min_lines: 40
    - path: "src/utils/cache.py"
      provides: "FileCache class with get/set/has methods"
      contains: "class FileCache"
      min_lines: 50
  key_links:
    - from: "src/models/content.py"
      to: "src/video/timing.py"
      via: "imports WordTiming for AudioResult.word_timings type"
      pattern: "from src.video.timing import WordTiming"
    - from: "src/utils/cache.py"
      to: "cache/"
      via: "stores JSON files in cache subdirectories"
      pattern: "Path.*cache"
---

<objective>
Create content data models and file-based caching foundation for all content generation services.

Purpose: Provide type-safe data structures and caching infrastructure that ScriptGenerator, VideoFetcher, and AudioSynthesizer will use to prevent redundant API calls and preserve generated content.

Output: `src/models/content.py` with dataclasses, `src/utils/cache.py` with FileCache class.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-content-generation-services/05-RESEARCH.md

# Existing models to reference
@src/models/brand.py
@src/video/timing.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create content dataclasses</name>
  <files>src/models/content.py, src/models/__init__.py</files>
  <action>
Create `src/models/content.py` with three dataclasses:

1. **Script** - Generated script with metadata:
   - `topic: str` - The video topic
   - `voiceover: str` - Full voiceover text
   - `search_terms: list[str]` - Pexels search keywords
   - `brand_slug: str` - Brand identifier
   - `cta_text: str` - Call-to-action text
   - `estimated_duration: float` - Estimated seconds (calculate from word count at ~150 words/min)
   - Add `to_dict()` and `from_dict()` methods for serialization

2. **AudioResult** - TTS generation result:
   - `audio_path: Path` - Path to generated audio file
   - `word_timings: list[WordTiming]` - Word-level timing from TTS
   - `duration_ms: float` - Total audio duration in milliseconds
   - Import `WordTiming` from `src.video.timing`

3. **GeneratedContent** - Complete generated content bundle:
   - `script: Script` - The generated script
   - `video_path: Path` - Path to downloaded stock video
   - `audio_result: AudioResult` - TTS result with timing
   - `metadata: dict` - Additional metadata (timestamps, cache keys, etc.)

Use `from dataclasses import dataclass, asdict, field` for clean implementation.
Use `from pathlib import Path` for file paths.
Use Python 3.9 compatible type hints (import from typing if needed).

Update `src/models/__init__.py` to export all three dataclasses.
  </action>
  <verify>
```bash
cd /Users/homefolder/social-media-empire
python -c "from src.models.content import Script, AudioResult, GeneratedContent; s = Script(topic='test', voiceover='Hello world', search_terms=['nature'], brand_slug='test', cta_text='Click now', estimated_duration=5.0); print(s.to_dict())"
```
  </verify>
  <done>Script, AudioResult, GeneratedContent dataclasses created with serialization methods, exported from src.models</done>
</task>

<task type="auto">
  <name>Task 2: Create file-based cache utilities</name>
  <files>src/utils/cache.py, src/utils/__init__.py</files>
  <action>
Create `src/utils/cache.py` with a `FileCache` class:

```python
class FileCache:
    """File-based JSON cache with hash keys.

    Stores cached data as JSON files in subdirectories under cache/.
    Keys are hashed to prevent filesystem issues with special characters.

    Usage:
        cache = FileCache("scripts")  # -> cache/scripts/
        cache.set("key", {"data": "value"})
        data = cache.get("key")  # Returns dict or None
    """
```

Implementation requirements:

1. **Constructor**: `__init__(self, subdirectory: str, cache_root: Path = None)`
   - Default cache_root to `Path("cache")`
   - Create subdirectory if not exists
   - Store logger instance

2. **Hash key generation**: `_hash_key(self, content: str) -> str`
   - Use `hashlib.sha256(content.encode()).hexdigest()[:16]`
   - 16 chars is enough for uniqueness, keeps filenames short

3. **Cache path**: `_cache_path(self, key: str) -> Path`
   - Returns `cache_root / subdirectory / f"{hashed_key}.json"`

4. **Get**: `get(self, key: str) -> Optional[dict]`
   - Return None if file doesn't exist
   - Parse JSON and return dict
   - Log cache HIT or MISS with key (use logger.debug for HIT, logger.info for MISS)

5. **Set**: `set(self, key: str, data: dict) -> None`
   - Write JSON with indent=2 for readability
   - Log cache WRITE with key and file size

6. **Has**: `has(self, key: str) -> bool`
   - Return True if cache file exists

7. **Delete**: `delete(self, key: str) -> bool`
   - Delete cache file if exists, return True if deleted

8. **Clear**: `clear(self) -> int`
   - Delete all files in subdirectory, return count deleted

Add version prefix to keys for cache invalidation:
```python
CACHE_VERSION = "v1"

def _hash_key(self, content: str) -> str:
    versioned = f"{CACHE_VERSION}_{content}"
    return hashlib.sha256(versioned.encode()).hexdigest()[:16]
```

Update `src/utils/__init__.py` to export FileCache.

Ensure proper error handling - log warnings on JSON parse errors, don't crash.
  </action>
  <verify>
```bash
cd /Users/homefolder/social-media-empire
python -c "
from src.utils.cache import FileCache
cache = FileCache('test_cache')
cache.set('mykey', {'data': 'value'})
result = cache.get('mykey')
print(f'Got: {result}')
assert result == {'data': 'value'}, 'Cache get failed'
assert cache.has('mykey'), 'Cache has failed'
cache.delete('mykey')
assert not cache.has('mykey'), 'Cache delete failed'
print('All cache tests passed')
"
```
  </verify>
  <done>FileCache class created with get/set/has/delete/clear methods, hash key generation, and version prefix for cache invalidation</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Models importable:**
```bash
python -c "from src.models import Script, AudioResult, GeneratedContent; print('Models OK')"
```

2. **Cache utility works:**
```bash
python -c "from src.utils import FileCache; print('Cache OK')"
```

3. **Integration test:**
```bash
python -c "
from src.models.content import Script
from src.utils.cache import FileCache

cache = FileCache('scripts')
script = Script(
    topic='Wellness tips',
    voiceover='Here are some tips...',
    search_terms=['wellness', 'health'],
    brand_slug='menopause',
    cta_text='Visit our Etsy shop',
    estimated_duration=30.0
)
cache.set('test_script', script.to_dict())
loaded = Script.from_dict(cache.get('test_script'))
assert loaded.topic == script.topic
print('Integration test passed')
"
```
</verification>

<success_criteria>
1. Script dataclass has all required fields and to_dict/from_dict methods
2. AudioResult correctly references WordTiming from src.video.timing
3. GeneratedContent bundles all content components
4. FileCache stores/retrieves JSON with hash keys
5. Cache version prefix enables future invalidation
6. All imports work without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-content-generation-services/05-01-SUMMARY.md`
</output>
