---
phase: 05-content-generation-services
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/services/script_generator.py
  - src/services/__init__.py
autonomous: true

must_haves:
  truths:
    - "ScriptGenerator generates brand-appropriate topic from brand config"
    - "ScriptGenerator creates voiceover script with CTA naturally integrated"
    - "ScriptGenerator returns Pexels search terms matching script content"
    - "Script adapts to brand voice (menopause=warm/supportive, deals=excited, fitness=energetic)"
    - "Cache hit returns existing script without calling Gemini API"
    - "Cache miss calls Gemini and stores result before returning"
  artifacts:
    - path: "src/services/script_generator.py"
      provides: "ScriptGenerator class with generate() method"
      contains: "class ScriptGenerator"
      min_lines: 100
  key_links:
    - from: "src/services/script_generator.py"
      to: "src/clients/gemini.py"
      via: "uses GeminiClient.generate_text for topic and script"
      pattern: "GeminiClient|generate_text"
    - from: "src/services/script_generator.py"
      to: "src/utils/cache.py"
      via: "uses FileCache for caching generated scripts"
      pattern: "FileCache"
    - from: "src/services/script_generator.py"
      to: "src/models/content.py"
      via: "returns Script dataclass"
      pattern: "from src.models.content import Script"
---

<objective>
Create ScriptGenerator service that generates brand-appropriate topics and voiceover scripts using Gemini, with file-based caching to prevent quota exhaustion.

Purpose: Transform the Gemini API client into a higher-level service that understands brand context and produces ready-to-use video scripts with CTAs and Pexels search terms.

Output: `src/services/script_generator.py` with ScriptGenerator class.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-content-generation-services/05-RESEARCH.md
@.planning/phases/05-content-generation-services/05-01-SUMMARY.md

# Existing code to use
@src/clients/gemini.py
@src/models/brand.py
@src/models/content.py
@src/utils/cache.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScriptGenerator with brand-specific prompts</name>
  <files>src/services/script_generator.py</files>
  <action>
Create `src/services/script_generator.py` with:

```python
class ScriptGenerator:
    """Generate video scripts with brand-specific tone and CTAs.

    Uses Gemini for text generation with file-based caching to prevent
    quota exhaustion on the 5 RPM free tier limit.

    Cache key: hash(brand_slug + topic_seed + date)
    Including date ensures fresh content daily while allowing same-day reruns.
    """
```

**Brand Voice Prompts** (class attribute):
```python
BRAND_VOICES = {
    "menopause": {
        "tone": "warm, supportive, and understanding",
        "audience": "women navigating menopause",
        "style": "empathetic, informative, reassuring"
    },
    "daily_deal": {
        "tone": "excited, enthusiastic, and deal-savvy",
        "audience": "bargain hunters and smart shoppers",
        "style": "energetic, urgent but not pushy, value-focused"
    },
    "fitness": {
        "tone": "motivational, energetic, and encouraging",
        "audience": "people starting or maintaining fitness journeys",
        "style": "upbeat, can-do attitude, practical"
    }
}
DEFAULT_VOICE = {
    "tone": "friendly and informative",
    "audience": "general audience",
    "style": "clear, engaging, helpful"
}
```

**Constructor**:
```python
def __init__(self, gemini_client: GeminiClient = None):
    self.client = gemini_client or GeminiClient()
    self.cache = FileCache("scripts")
    self.logger = logging.getLogger(self.__class__.__name__)
```

**Topic Generation Prompt** (private method `_build_topic_prompt`):
```
You are generating a video topic for {brand_name}.
Brand voice: {voice[tone]}
Target audience: {voice[audience]}
Brand description: {brand_description}

Generate ONE unique, engaging topic for a 30-45 second video.
The topic should:
- Be relevant to {voice[audience]}
- Have visual potential (can be illustrated with stock footage)
- Be specific enough to be interesting, not generic

Return ONLY the topic as a single sentence, no quotes or extra text.
```

**Script Generation Prompt** (private method `_build_script_prompt`):
```
You are a video scriptwriter for {brand_name}.
Brand voice: {voice[tone]}
Style: {voice[style]}
CTA: "{cta_text}" leading to {cta_url}

Write a voiceover script for a {target_duration}-second video about:
{topic}

Requirements:
1. Start with a hook that grabs attention in the first 3 seconds
2. Provide valuable, specific information in 3-4 sentences
3. End by naturally mentioning the CTA - don't say "click the link", weave it in conversationally
4. Use conversational, spoken language - this will be read aloud
5. Keep it to {word_count} words maximum (about {target_duration} seconds of speech)

After the script, list 3-5 Pexels search terms that would find good background video footage.

Format your response EXACTLY like this:
VOICEOVER:
[Your script here - just the spoken words, no stage directions]

SEARCH_TERMS:
[comma-separated search terms]
```

**Cache key generation** (private method `_cache_key`):
```python
def _cache_key(self, brand_slug: str, topic_seed: str = None) -> str:
    from datetime import date
    seed = topic_seed or "random"
    key_content = f"{brand_slug}_{seed}_{date.today().isoformat()}"
    return key_content
```
  </action>
  <verify>
```bash
cd /Users/homefolder/social-media-empire
python -c "
from src.services.script_generator import ScriptGenerator
sg = ScriptGenerator.__new__(ScriptGenerator)
prompt = sg._build_topic_prompt.__doc__ if hasattr(sg, '_build_topic_prompt') else 'method exists'
print('ScriptGenerator class created')
print('BRAND_VOICES:', list(ScriptGenerator.BRAND_VOICES.keys()))
"
```
  </verify>
  <done>ScriptGenerator class created with brand voice prompts and prompt builder methods</done>
</task>

<task type="auto">
  <name>Task 2: Implement generate method with caching</name>
  <files>src/services/script_generator.py, src/services/__init__.py</files>
  <action>
Add the main `generate` method to ScriptGenerator:

```python
def generate(
    self,
    brand_config: BrandConfig,
    topic_seed: str = None,
    target_duration: int = 35
) -> Script:
    """Generate a video script for the given brand.

    Args:
        brand_config: Brand configuration with name, colors, CTA, etc.
        topic_seed: Optional seed for reproducible topic generation
        target_duration: Target video duration in seconds (default 35)

    Returns:
        Script dataclass with topic, voiceover, search_terms, etc.

    Flow:
        1. Check cache for existing script
        2. If cache miss: generate topic with Gemini
        3. Generate full script with Gemini
        4. Parse response into Script dataclass
        5. Cache and return
    """
```

Implementation details:

1. **Cache check first**:
```python
cache_key = self._cache_key(brand_config.slug, topic_seed)
cached = self.cache.get(cache_key)
if cached:
    self.logger.info(f"Cache HIT for {brand_config.slug}", extra={"cache_key": cache_key})
    return Script.from_dict(cached)
self.logger.info(f"Cache MISS for {brand_config.slug}", extra={"cache_key": cache_key})
```

2. **Generate topic**:
```python
voice = self.BRAND_VOICES.get(brand_config.slug, self.DEFAULT_VOICE)
topic_prompt = self._build_topic_prompt(brand_config, voice)
topic = self.client.generate_text(topic_prompt, max_tokens=100, temperature=0.9).strip()
```

3. **Generate script** (with word count calculation):
```python
# ~150 words per minute, so target_duration seconds = target_duration * 2.5 words
word_count = int(target_duration * 2.5)
script_prompt = self._build_script_prompt(brand_config, voice, topic, target_duration, word_count)
response = self.client.generate_text(script_prompt, max_tokens=500, temperature=0.7)
```

4. **Parse response** (private method `_parse_response`):
```python
def _parse_response(self, response: str, brand_config: BrandConfig, topic: str) -> Script:
    """Parse Gemini response into Script dataclass."""
    voiceover = ""
    search_terms = []

    if "VOICEOVER:" in response and "SEARCH_TERMS:" in response:
        parts = response.split("SEARCH_TERMS:")
        voiceover = parts[0].replace("VOICEOVER:", "").strip()
        search_terms = [t.strip() for t in parts[1].strip().split(",")]
    else:
        # Fallback: treat entire response as voiceover
        voiceover = response.strip()
        search_terms = ["lifestyle", "nature", "wellness"]
        self.logger.warning("Could not parse structured response, using fallback search terms")

    # Estimate duration: ~150 words per minute = 2.5 words per second
    word_count = len(voiceover.split())
    estimated_duration = word_count / 2.5

    return Script(
        topic=topic,
        voiceover=voiceover,
        search_terms=search_terms[:5],  # Max 5 terms
        brand_slug=brand_config.slug,
        cta_text=brand_config.cta_text,
        estimated_duration=estimated_duration
    )
```

5. **Cache and return**:
```python
script = self._parse_response(response, brand_config, topic)
self.cache.set(cache_key, script.to_dict())
self.logger.info(
    f"Generated script for {brand_config.slug}",
    extra={
        "topic": topic[:50],
        "duration_est": script.estimated_duration,
        "search_terms": script.search_terms
    }
)
return script
```

Update `src/services/__init__.py` to export ScriptGenerator:
```python
from src.services.script_generator import ScriptGenerator

__all__ = ["ScriptGenerator"]
```
  </action>
  <verify>
```bash
cd /Users/homefolder/social-media-empire
# Test with mock (no API call needed for import/structure test)
python -c "
from src.services import ScriptGenerator
from src.models.brand import BrandConfig, ColorPalette

# Create test brand config
config = BrandConfig(
    name='Test Brand',
    slug='test',
    colors=ColorPalette(primary='#000000', secondary='#ffffff'),
    tts_voice='en-US-JennyNeural',
    cta_text='Visit our shop',
    cta_url='https://example.com'
)

# Verify class structure
sg = ScriptGenerator.__new__(ScriptGenerator)
print('generate method exists:', hasattr(ScriptGenerator, 'generate'))
print('_parse_response exists:', hasattr(ScriptGenerator, '_parse_response'))
print('ScriptGenerator ready for use')
"
```
  </verify>
  <done>ScriptGenerator.generate() method implemented with caching, topic generation, script generation, and response parsing</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **ScriptGenerator importable:**
```bash
python -c "from src.services import ScriptGenerator; print('Import OK')"
```

2. **Brand voices configured:**
```bash
python -c "
from src.services.script_generator import ScriptGenerator
voices = ScriptGenerator.BRAND_VOICES
assert 'menopause' in voices, 'Missing menopause voice'
assert 'daily_deal' in voices, 'Missing daily_deal voice'
assert 'fitness' in voices, 'Missing fitness voice'
print('All brand voices configured')
"
```

3. **Parse response fallback works:**
```bash
python -c "
from src.services.script_generator import ScriptGenerator
from src.models.brand import BrandConfig, ColorPalette

sg = ScriptGenerator.__new__(ScriptGenerator)
sg.logger = __import__('logging').getLogger('test')

config = BrandConfig(
    name='Test', slug='test',
    colors=ColorPalette(primary='#000', secondary='#fff'),
    tts_voice='test', cta_text='CTA', cta_url='http://x.com'
)

# Test parsing
result = sg._parse_response(
    'VOICEOVER:\nHello world.\n\nSEARCH_TERMS:\nnature, wellness',
    config, 'Test topic'
)
assert result.voiceover == 'Hello world.'
assert 'nature' in result.search_terms
print('Response parsing works')
"
```
</verification>

<success_criteria>
1. ScriptGenerator generates topic using brand-specific prompt (SCRIPT-01)
2. Script includes voiceover with CTA naturally integrated (SCRIPT-02, AUDIO-03)
3. Script includes Pexels search terms (SCRIPT-03)
4. Brand voice adapts to menopause/deals/fitness tone (SCRIPT-04)
5. Cache prevents redundant Gemini API calls
6. Fallback parsing handles unexpected Gemini responses
</success_criteria>

<output>
After completion, create `.planning/phases/05-content-generation-services/05-02-SUMMARY.md`
</output>
